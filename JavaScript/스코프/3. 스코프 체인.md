## 스코프 체인
* 함수는 전역에서도, 지역(함수 몸체 내부)에서도 정의할 수 있다.
  * 함수의 중첩 : 함수 내부에 함수가 정의된 것
  * 중첩합수 : 함수 몸체 내부에 정한 함수
  * 외부함수 : 중첩 함수를 포함하는 함수
* 스코프는 함수의 중첩에 의해 계층적 구조를 갖는다.
  * 함수가 중첩될 수 있듯이, 함수의 지역 스코프도 중첩될 수 있는 것과 같다.

* 앞서 나온 코드의 계층 구조를 나타내면 아래와 같다.

![스코프 체인](https://github.com/5nam/TIL/blob/master/JavaScript/%EC%8A%A4%EC%BD%94%ED%94%84/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-02-03%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2010.02.17.png)

* 모든 스코프는 하나의 계층적 구조로 연결되며, 최상위 스코프는 전역 스코프다.
* 스코프 체인 : 스코프가 계층적으로 연결된 것
  * 변수를 참조할 때 JS 엔진은 스코프 체인에 기반하여, 변수를 참조하는 코드의 스코프에서 시작하여 상위 방향으로 이동하며 선언된 변수를 검색한다.

* 스코프 체인은 물리적인 실체로 존재한다.
  * JS 엔진은 코드(전역코드와 함수 코드)를 실행하기에 앞서, 위 그림과 유사한 자료구조인 **렉시컬 환경**을 실제로 생성한다.
  * 변수 선언이 실행되면 변수 식별자가 **렉시컬 환경** 자료구조에 키로 등록되고, 변수가 할당되면 이 자료구조의 변수 식별자에 해당하는 값을 변경한다. 변수의 검색도 이 자료구조 상에서 이뤄진다.
  
### 스코프 체인에 의한 변수 검색
~~~
var x = 'global x';
var y = 'global y';
function outer() {
  var z = 'outer's local z';
  
  console.log(x); // 1. global x
  console.log(y); // 1. global y
  console.log(z); // 1. outer's local z
   
  function inner() {
    var x = 'inner's local x';
    
    console.log(x); // 4. inner's local x
    console.log(y); // 5. global y
    console.log(z); // 6. outer's local z
  }
  
  inner();
}
outer();
console.log(x); // 7. global x
console.log(z); // ReferenceError: z is not defined
~~~

* JS 엔진은 스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색
  * 4번
    1. inner 함수(x 변수를 참조하는 코드의 스코프)의 지역 스코프에서 x 변수가 선언되었는지 검색
    2. inner 함수 내에 선언된 x 변수 존재
    3. 따라서 검색된 변수를 참조하고 검색 종료
  * 5번
    1. inner 함수(y 변수를 참조하는 코드의 스코프)의 지역 스코프에서 y 변수가 선언되었는지 검색
    2. inner 함수 내에 y 변수 선언 존재 X
    3. 상위 스코프인 outer 함수의 지역 스코프로 이동
    4. outer 함수 내에는 y 변수의 선언이 존재 X
    5. 다시 상위 스코프인 전역 스코프로 이동
    6. 전역 스코프에는 y 변수 선언 존재
    7. 따라서 검색된 변수를 참조하고 검색 종료.
  * 6번
    1. inner 함수(z 변수를 참조하는 코드의 스코프)의 지역 스코프에서 z 변수가 선언되었는지 검색
    2. inner 함수 내에는 z 변수 선언 존재 X
    3. 상위 스코프인 outer 함수의 지역 스코프로 이동
    4. outer 함수 내에는 z 변수 선언 존재.
    5. 따라서 검색된 변수 참조하고 검색 종료

* 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다.
  * 스코프 체인으로 연결되 스코프의 계층적 구조는 상속과 유사하다
  * 부모의 자산을 자식이 자유롭게 사용할 수 있지만, 자식의 자산을 부모가 사용할 수 없다.

### 스코프 체인에 의한 함수 검색
~~~
// 전역 함수
function foo() {
  console.log('global function foo');
}

function bar() {
  // 중첩 함수
  function foo() {
    console.log('local function foo');
  }
  
  foo(); // 1
}

bar();
~~~
* 함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성되고, JS 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 선언하고 생성된 함수 객체를 할당한다.
  * 따라서 위 예제의 모든 함수는 함수 이름과 동일한 이름의 식별자에 할당된다.
  * 1 에서 foo 함수를 호출하면 JS 엔진은 함수를 호출하기 위해 먼저 함수를 가리키는 식별자 foo 를 검색한다.
* 이런 과정이 일반 변수와 다를 바가 없기 때문에 스코프를 **식별자를 검색하는 규칙**이라고 표현하는 것이 적합하다.


출처 : 이웅모, 모던 자바스크립트 Deep Dive, (위키북스), p.194-p.197
